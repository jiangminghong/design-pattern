# design-pattern：proxy （结构型）
代理模式:给某一个对象提供一个代理对象，由代理对象来控制原对象的引用。
适用场景：在某些情况下，不想或不能直接引用被代理对象时。代理类起到中介的作用。
其特征是代理类和委托类实现相同的接口。代理类除了中介作用外，还可以通过代理类
增加额外的功能，但是代理类本身不实现真正的业务，他主要负责为被代理对象预处理或者
处理返回的结果。

静态代理：显示的知道代理对象。

动态代理：
    JDk自带：通过实现接口来实现的；实现invocationHandler，被代理对象必须实现接口。
    CGLib代理：代理对象是被代理对象的子类，不需要接口，通过字节码技术为一个类创建子类，
    并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。不能对final的
    类和方法进行代理
区别：
    1.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
    2.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
    3.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。